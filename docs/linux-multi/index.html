<!DOCTYPE html>
<html>
<head>
<title>index.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<!-- _class: lead -->
<h1 id="a-decate-of-wasted-cores">A Decate of wasted cores</h1>
<h2 id="why-building-a-multi-core-scheduler-is-hard">Why building a multi-core scheduler is hard</h2>
<hr>
<h1 id="table-of-contents">Table of contents</h1>
<ul>
<li>lmao</li>
</ul>
<hr>
<h1 id="why-cpus-are-so-fast">Why CPUs are so fast</h1>
<ul>
<li>Clock speed</li>
<li>Cores</li>
<li>Cache</li>
<li>Pipelining</li>
<li>Hyperthreading</li>
<li>...</li>
</ul>
<!--

Modern CPUs (Central Processing Units) are fast due to a combination of architectural advancements, manufacturing improvements, and sophisticated techniques to optimize data flow and processing. However, these advancements also bring about certain challenges. Let's explore the reasons for their speed and the relevant problems including the Von Neumann bottleneck, cache locality, branch prediction, runahead execution, and levels of cache.

### Reasons for Speed

1. **Microarchitecture Improvements**: Over the years, CPU designs have become more efficient, with improvements in pipelining, out-of-order execution, and speculative execution, allowing for more instructions to be processed simultaneously and more efficiently.

2. **Manufacturing Technology**: Advances in semiconductor technology have allowed for smaller transistors. Smaller transistors mean faster switching times and lower power consumption, allowing for more transistors to be packed into the same chip area (Moore's Law). This has led to more complex and powerful CPUs.

3. **Clock Speed**: Increases in the clock speed, the rate at which a processor can complete a processing cycle, have historically contributed to CPU performance. However, due to thermal and power constraints, this is less of a factor now.

4. **Parallelism**: Modern CPUs often have multiple cores, allowing them to perform multiple tasks simultaneously. Additionally, techniques like SIMD (Single Instruction, Multiple Data) enable a single instruction to perform operations on multiple data points simultaneously.

### Relevant Problems

1. **Von Neumann Bottleneck**: This term describes the limitation on throughput caused by the traditional CPU architecture where the same bus is used to fetch both data and instructions. This means that the speed at which data can be fed into the CPU for processing is limited, potentially slowing down execution despite the CPU's capability to process data quickly.

2. **Cache Locality**: Modern CPUs use caches—small, fast memory located close to the CPU cores—to store copies of frequently accessed data and instructions. Cache locality refers to the efficient use of the cache by accessing data in a way that minimizes cache misses. Poor cache locality can lead to frequent cache misses, causing the CPU to waste time fetching data from slower, main memory.

3. **Branch Prediction**: CPUs use branch prediction to guess which way a branch (e.g., an if-else statement) will go so that they can continue executing instructions without waiting for the branch to be resolved. Incorrect predictions can lead to a performance penalty as the CPU needs to discard the incorrectly speculated instructions and fetch the correct ones.

4. **Runahead Execution**: This is a technique to improve CPU utilization during cache misses. Instead of idling, the CPU can execute future instructions that do not depend on the missed data. This can improve performance but requires sophisticated hardware mechanisms to manage and predict dependencies accurately.

5. **Levels of Cache**: Modern CPUs have multiple levels of cache (L1, L2, and sometimes L3 and L4), each with different sizes and speeds. Managing these levels efficiently is crucial for performance. L1 cache is the fastest but smallest, designed for speed, while L2 and L3 caches are larger but slower, designed to hold more data and reduce trips to main memory. Balancing what data is stored in each level of cache to maximize speed and efficiency is a complex problem.

In summary, while modern CPUs are fast due to several architectural and technological advancements, they also face challenges related to the inherent limitations of their design and the complexities of efficiently managing data flow and processing. Addressing these challenges requires ongoing innovation in CPU design and architecture.

-->
<hr>
<h1 id="von-neumann-bottleneck">Von Neumann Bottleneck</h1>
<p><img src="von-neumann.png" alt="height:500px"></p>
<hr>
<h1 id="issues">Issues</h1>
<ul>
<li>The bottleneck occurs because the data transfer rate between the CPU and memory is significantly lower than the rate at which the CPU can process data.</li>
<li>This discrepancy leads to the CPU often waiting for data to process, reducing overall system efficiency.</li>
<li>Slows down computing processes.</li>
<li>Limits the performance of high-speed CPUs.</li>
<li>Affects the execution of complex programs and multitasking operations.</li>
</ul>
<hr>
<h1 id="harvard-architecture">Harvard Architecture</h1>
<p><img src="harvard-model.png" alt="height:500px"></p>
<hr>
<h1 id="numa">NUMA</h1>
<blockquote>
<p>Non-Uniform Memory Access</p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/95/Hwloc.png/1280px-Hwloc.png" alt=""></p>
<!--

NUMA is a computer memory design used in multiprocessing, where the memory access time depends on the memory location relative to the processor. Under NUMA, a processor can access its own local memory faster than non-local memory (memory local to another processor or memory shared between processors).

-->
<hr>

</body>
</html>
